// __xxxxxxxxxxxxxxxx___.
// _gxXXXXXXXXXXXXXXXXXXXXXXXX!x_
// __x!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX!x_
// ,gXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx_
// ,gXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX!_
// _!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX!.
// gXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXs
// ,!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX!.
// g!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX!
// iXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX!
// ,XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx
// !XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx
// ,XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx
// !XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXi
// dXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX!
// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX!
// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX!
// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX!
// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX!
// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX!
// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// !XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// XXXXXXXXXXXXXXXXXXXf~~~VXXXXXXXXXXXXXXXXXXXXXXXXXXvvvvvvvvXXXXXXXXXXXXXX!
// !XXXXXXXXXXXXXXXf`       'XXXXXXXXXXXXXXXXXXXXXf`          '~XXXXXXXXXXP
// vXXXXXXXXXXXX!            !XXXXXXXXXXXXXXXXXX!              !XXXXXXXXX
// XXXXXXXXXXv`              'VXXXXXXXXXXXXXXX                !XXXXXXXX!
// !XXXXXXXXX.                 YXXXXXXXXXXXXX!                XXXXXXXXX
// XXXXXXXXX!                 ,XXXXXXXXXXXXXX                VXXXXXXX!
// 'XXXXXXXX!                ,!XXXX ~~XXXXXXX               iXXXXXX~
// 'XXXXXXXX               ,XXXXXX   XXXXXXXX!             xXXXXXX!
// !XXXXXXX!xxxxxxs______xXXXXXXX   'YXXXXXX!          ,xXXXXXXXX
// YXXXXXXXXXXXXXXXXXXXXXXXXXXX`    VXXXXXXX!s. __gxx!XXXXXXXXXP
// XXXXXXXXXXXXXXXXXXXXXXXXXX!      'XXXXXXXXXXXXXXXXXXXXXXXXX!
// XXXXXXXXXXXXXXXXXXXXXXXXXP        'YXXXXXXXXXXXXXXXXXXXXXXX!
// XXXXXXXXXXXXXXXXXXXXXXXX!     i    !XXXXXXXXXXXXXXXXXXXXXXXX
// XXXXXXXXXXXXXXXXXXXXXXXX!     XX   !XXXXXXXXXXXXXXXXXXXXXXXX
// XXXXXXXXXXXXXXXXXXXXXXXXx_   iXX_,_dXXXXXXXXXXXXXXXXXXXXXXXX
// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXP
// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX!
// ~vXvvvvXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXf
// 'VXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXvvvvvv~
// 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX~
// _    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXv`
// -XX!  !XXXXXXX~XXXXXXXXXXXXXXXXXXXXXX~   Xxi
// YXX  '~ XXXXX XXXXXXXXXXXXXXXXXXXX`     iXX`
// !XX!    !XXX` XXXXXXXXXXXXXXXXXXXX      !XX
// !XXX    '~Vf  YXXXXXXXXXXXXXP YXXX     !XXX
// !XXX  ,_      !XXP YXXXfXXXX!  XXX     XXXV
// !XXX !XX           'XXP 'YXX!       ,.!XXX!
// !XXXi!XP  XX.                  ,_  !XXXXXX!
// iXXXx X!  XX! !Xx.  ,.     xs.,XXi !XXXXXXf
// XXXXXXXXXXXXXXXXX! _!XXx  dXXXXXXX.iXXXXXX
// VXXXXXXXXXXXXXXXXXXXXXXXxxXXXXXXXXXXXXXXX!
// YXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXV
// 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX!
// 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXf
// VXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXf
//  VXXXXXXXXXXXXXXXXXXXXXXXXXXXXv`
//   ~vXXXXXXXXXXXXXXXXXXXXXXXf`
//       ~vXXXXXXXXXXXXXXXXv~
//          '~VvXXXXXXXV~~
//                ~~

const Scene = require("Scene");
var Touch = require("TouchGestures");
var Animation = require("Animation");
const Audio = require("Audio");

// MUSIC
// ______________________________________________

const dindada = Scene.root.find("dindada");

// SEQUENCE TIMERS
// ______________________________________________

const openingDriver = Animation.timeDriver({ durationMilliseconds: 20000 });

const postOpeningPauseDriver = Animation.timeDriver({
  durationMilliseconds: 4000
});

const slowLightTriggerDriver = Animation.timeDriver({
  durationMilliseconds: 49000
});

const swappingTriggerDriver = Animation.timeDriver({
  durationMilliseconds: 62000
});

const deathTextTriggerDriver = Animation.timeDriver({
  durationMilliseconds: 77000
});

const faceFlashTriggerDriver = Animation.timeDriver({
  durationMilliseconds: 92000
});

const headWithKnifeTriggerDriver = Animation.timeDriver({
  durationMilliseconds: 96000
});

// INTERACTIONS
// ______________________________________________

Touch.onTap().subscribe(e => {
  if (!itHasBegun) {
    triggerPrequel();
  } else if (openingHasCompleted) {
    toggleKnives();
  }
});

// PREQUEL TEXT
// ______________________________________________

const prequelTextCanvas = Scene.root.find("prequelTextCanvas");
const prequelText = Scene.root.find("prequelText");
const prequelTextWords = [
  "The",
  "best",
  "thing",
  "about",
  "being",
  "dead",
  "dead",
  "dead",
  "is",
  "that",
  "you",
  "no",
  "longer",
  "have",
  "to",
  "say",
  "say",
  "say",
  "I",
  "wish",
  "I",
  "were",
  "dead.",
  "dead.",
  "dead.",
  "The",
  "best",
  "thing",
  "about",
  "being",
  "alive",
  "alive",
  "is",
  "you",
  "can",
  "still",
  "say",
  "say",
  "say",
  "I",
  "wish",
  "I",
  "were",
  "dead.",
  "dead.",
  "One face. Tap the blades. Sound on."
];

// Initial state
let itHasBegun = false;
let prequelTextIndex = 0;
prequelText.text = prequelTextWords[prequelTextIndex];
prequelTextCanvas.hidden = false;

// Drivers
const prequelTextChangeDriver = Animation.timeDriver({
  durationMilliseconds: 300
});
const prequelTextInstructionsDriver = Animation.timeDriver({
  durationMilliseconds: 4000
});

prequelTextChangeDriver.onCompleted().subscribe(f => {
  prequelTextChangeDriver.reset();
  prequelTextChangeDriver.start();

  if (prequelTextIndex === prequelTextWords.length) {
    prequelTextInstructionsDriver.start();
  } else {
    prequelText.text = prequelTextWords[prequelTextIndex];
    prequelTextIndex++;
  }
});

const triggerPrequel = () => {
  itHasBegun = true;
  Audio.play(dindada);
  prequelTextChangeDriver.start();
};

prequelTextInstructionsDriver.onCompleted().subscribe(f => {
  prequelTextCanvas.hidden = true;
  triggerOpening();
});

// OPENING
// ______________________________________________

const openingSampler = Animation.samplers.easeInCubic(490, 280);
const positionAnimation = Animation.animate(openingDriver, openingSampler);
let openingHasCompleted = false;

const triggerOpening = () => {
  introTextPlane.hidden = false;
  openingDriver.start();
  slowLightTriggerDriver.start();
  swappingTriggerDriver.start();
  deathTextTriggerDriver.start();
  faceFlashTriggerDriver.start();
  headWithKnifeTriggerDriver.start();
  introTextPlane.transform.z = positionAnimation;
};

openingDriver.onCompleted().subscribe(f => {
  postOpeningPauseDriver.start();
});

postOpeningPauseDriver.onCompleted().subscribe(f => {
  openingHasCompleted = true;
  introTextPlane.hidden = true;
  smallTextCanvas.hidden = false;
  knifeDriver.start();
  hideKnifeFace(false);
  toggleKnives();
});

// TIMER TEXT
// ______________________________________________

const introTextPlane = Scene.root.find("introTextPlane");
const timeTop = Scene.root.find("timeTop");
const timeBottom = Scene.root.find("timeBottom");
introTextPlane.hidden = true;

const timeOfDeathSmall = Scene.root.find("timeOfDeathSmall");
const smallTextCanvas = Scene.root.find("smallTextCanvas");
smallTextCanvas.hidden = true;

const milliTimeDriver = Animation.timeDriver({ durationMilliseconds: 1 });
milliTimeDriver.start();

const getTime = () => {
  const timeNow = new Date(Date.now());
  const timeFormatted = timeNow.toLocaleTimeString("en-US", { hour12: false });
  const milliseconds = timeNow.getUTCMilliseconds();

  return {
    timeFormatted,
    milliseconds
  };
};

milliTimeDriver.onCompleted().subscribe(f => {
  const { timeFormatted, milliseconds } = getTime();

  if (openingHasCompleted) {
    timeOfDeathSmall.text = `${timeFormatted}:${milliseconds}`;
  } else {
    timeTop.text = `${timeFormatted}`;
    timeBottom.text = `${milliseconds}`;
  }

  milliTimeDriver.reset();
  milliTimeDriver.start();
});

// KNIVES
// ______________________________________________

const knifeFaceTracker = Scene.root.find("knifeFaceTracker");
const coveringCanvas = Scene.root.find("coveringCanvas");
const MeatCleaver = Scene.root.find("MeatCleaver");
const CelticDagger = Scene.root.find("CelticDagger");
const cleaverknife = Scene.root.find("cleaverknife");
const FantasyKnife = Scene.root.find("FantasyKnife");
coveringCanvas.hidden = true;
let currentKnifeIndex = 0;

const knives = [FantasyKnife, MeatCleaver, CelticDagger, cleaverknife];

const hideKnives = () => {
  for (let i = 0; i < knives.length; i++) {
    knives[i].hidden = true;
  }
};

hideKnives();

const knifeDriver = Animation.timeDriver({
  durationMilliseconds: 600000,
  loopCount: 3
});

const knifeSampler = Animation.samplers.linear(0, 360);
const knifeRotation = Animation.animate(knifeDriver, knifeSampler);

const toggleKnives = () => {
  currentKnifeIndex++;

  if (currentKnifeIndex === knives.length) {
    currentKnifeIndex = 0;
  }
  changeKnife();
};

const changeKnife = () => {
  hideKnives();
  knives[currentKnifeIndex].hidden = false;
  if (currentKnifeIndex === 0) {
    knives[currentKnifeIndex].transform.rotationY = knifeRotation;
  } else {
    knives[currentKnifeIndex].transform.rotationX = knifeRotation;
  }
};

// LIGHTS
// ______________________________________________

let angleIndex = 0;
let angleSetIndex = 0;
const angleSets = [[0, 180], [90, 270], [45, 225], [135, 315]];
const degreeDivisor = 180 / Math.PI;

// Initial light settings
const whiteLight = Scene.root.find("directionalLightWhite");
const redLight = Scene.root.find("directionalLightRed");

whiteLight.transform.rotationX = 0;
whiteLight.transform.rotationY = 130 / degreeDivisor;

redLight.transform.rotationX = 0;
redLight.transform.rotationY = 130 / degreeDivisor;
redLight.hidden = true;

// Utilities

const toggleLight = light => {
  if (light.hidden.lastValue) {
    light.hidden = false;
  } else {
    light.hidden = true;
  }
};

const rotateLight = light => {
  light.transform.rotationZ =
    angleSets[angleSetIndex][angleIndex] / degreeDivisor;
};

// Slow lights
const slowLightDriver = Animation.timeDriver({
  durationMilliseconds: 950
});
const slowLightSampler = Animation.samplers.easeInExpo(1, 0);
const slowLightIntensity = Animation.animate(slowLightDriver, slowLightSampler);
let overallCount = 0;

const changeAngle = driver => {
  driver.reset();
  driver.start();

  rotateLight(whiteLight);
  rotateLight(redLight);

  if (overallCount % 2 === 0) {
    toggleLight(whiteLight);
    toggleLight(redLight);
  }

  angleIndex++;
  overallCount++;
};

slowLightDriver.onCompleted().subscribe(f => {
  if (angleIndex >= angleSets[angleSetIndex].length) {
    angleIndex = 0;
  }
  changeAngle(slowLightDriver);
});

// Fast lights
const fastLightDriver = Animation.timeDriver({ durationMilliseconds: 30 });
const nextAngleSetFastDriver = Animation.timeDriver({
  durationMilliseconds: 500
});

nextAngleSetFastDriver.onCompleted().subscribe(f => {
  nextAngleSetFastDriver.reset();
  nextAngleSetFastDriver.start();
  angleSetIndex++;
  if (angleSetIndex >= angleSets.length) {
    angleSetIndex = 0;
  }
});

slowLightTriggerDriver.onCompleted().subscribe(f => {
  toggleKnifeFace();

  slowLightDriver.start();
  changeAngle(slowLightDriver);

  whiteLight.intensity = slowLightIntensity;
  redLight.intensity = slowLightIntensity;
});

// SWAPPING
// ______________________________________________

const whiteCover = Scene.root.find("whiteCover");

const swappingDriver = Animation.timeDriver({ durationMilliseconds: 750 });

const hideKnifeFace = bool => {
  knifeFaceTracker.hidden = bool;
  coveringCanvas.hidden = bool;
};

const toggleKnifeFace = () => {
  if (knifeFaceTracker.hidden.lastValue) {
    hideKnifeFace(false);
  } else {
    hideKnifeFace(true);
  }
};

swappingTriggerDriver.onCompleted().subscribe(f => {
  whiteCover.hidden = true;
  toggleKnifeFace();
  swappingDriver.start();
});

swappingDriver.onCompleted().subscribe(f => {
  if (!textDriverHasBegun) {
    swappingDriver.reset();
    swappingDriver.start();
    toggleKnifeFace();
  }
});

// TIME OF DEATH
// ______________________________________________

const deathTextCanvas = Scene.root.find("deathTextCanvas");
const deathText = Scene.root.find("deathText");
const deathTextWords = ["T", "I", "M", "E", "O", "F", "D", "E", "A", "T", "H"];

// Initial state
let deathTextIndex = 0;
deathText.text = deathTextWords[deathTextIndex];
deathTextCanvas.hidden = true;

let textDriverHasBegun = false;
let flashingHasEnded = false;

deathTextTriggerDriver.onCompleted().subscribe(f => {
  textDriverHasBegun = true;
  hideKnifeFace(true);
  deathTextCanvas.hidden = false;

  deathTextFlashDriver.start();
  deathTextChangeDriver.start();
});

const deathTextFlashDriver = Animation.timeDriver({ durationMilliseconds: 5 });
const deathTextChangeDriver = Animation.timeDriver({
  durationMilliseconds: 600
});
const deathTextMilliDriver = Animation.timeDriver({ durationMilliseconds: 1 });

deathTextFlashDriver.onCompleted().subscribe(f => {
  if (!flashingHasEnded) {
    deathTextFlashDriver.reset();
    deathTextFlashDriver.start();
  }
  toggleDeathText();
});

const toggleDeathText = () => {
  if (deathText.hidden.lastValue) {
    deathText.hidden = false;
  } else {
    deathText.hidden = true;
  }
};

deathTextChangeDriver.onCompleted().subscribe(f => {
  deathTextChangeDriver.reset();
  deathTextChangeDriver.start();

  if (deathTextIndex === deathTextWords.length) {
    flashingHasEnded = true;
    setDeathTextMilli();
    deathText.hidden = false;
    deathTextMilliDriver.start();
  } else {
    deathTextIndex++;
    deathText.text = deathTextWords[deathTextIndex];
  }
});

deathTextMilliDriver.onCompleted().subscribe(f => {
  deathTextMilliDriver.reset();
  deathTextMilliDriver.start();
  setDeathTextMilli();
});

const setDeathTextMilli = () => {
  const { timeFormatted, milliseconds } = getTime();
  deathText.text = `${timeFormatted}:${milliseconds}`;
};

// FACE FLASH
// ______________________________________________

faceFlashTriggerDriver.onCompleted().subscribe(f => {
  deathTextCanvas.hidden = true;
  changeAngle(fastLightDriver);
  nextAngleSetFastDriver.start();
  nextAngleSetFastDriver.start();
});

fastLightDriver.onCompleted().subscribe(f => {
  if (angleIndex >= angleSets[angleSetIndex].length) {
    angleIndex = 0;
  }
  changeAngle(fastLightDriver);
});

// HEAD WITH KNIFE
// ______________________________________________

const occluderFaceTracker = Scene.root.find("occluderFaceTracker");
const maskFaceTracker = Scene.root.find("maskFaceTracker");
const finalSceneCanvas = Scene.root.find("finalSceneCanvas");
const finalSceneTime = Scene.root.find("finalSceneTime");
const backWorldPlane = Scene.root.find("backWorldPlane");

finalSceneCanvas.hidden = true;
occluderFaceTracker.hidden = true;

headWithKnifeTriggerDriver.onCompleted().subscribe(f => {
  backWorldPlane.hidden = true;
  maskFaceTracker.hidden = true;
  occluderFaceTracker.hidden = false;
  finalSceneCanvas.hidden = false;
  const { timeFormatted, milliseconds } = getTime();
  finalSceneTime.text = `${timeFormatted}:${milliseconds}`;
});
